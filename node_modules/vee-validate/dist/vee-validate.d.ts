import * as vue from 'vue';
import { ComputedRef, Ref, WritableComputedRef, PropType } from 'vue';
import { SchemaOf, AnySchema, AnyObjectSchema, BaseSchema } from 'yup';

interface FieldContext {
    field: string;
    value: unknown;
    form: Record<string, unknown>;
    rule?: {
        name: string;
        params?: Record<string, unknown> | unknown[];
    };
}
declare type ValidationRuleFunction<TValue = unknown, TParams = unknown[] | Record<string, unknown>> = (value: TValue, params: TParams, ctx: FieldContext) => boolean | string | Promise<boolean | string>;
declare type SimpleValidationRuleFunction<TValue = unknown, TParams = unknown[] | Record<string, unknown>> = (value: TValue, params: TParams) => boolean | string | Promise<boolean | string>;
declare type ValidationMessageGenerator = (ctx: FieldContext) => string;

interface ValidationResult {
    errors: string[];
    valid: boolean;
}
declare type YupValidator = AnySchema | AnyObjectSchema;
declare type MaybeReactive<T> = Ref<T> | ComputedRef<T> | T;
interface FieldMeta<TValue> {
    touched: boolean;
    dirty: boolean;
    valid: boolean;
    pending: boolean;
    initialValue?: TValue;
}
interface FieldState<TValue = unknown> {
    value: TValue;
    touched: boolean;
    errors: string[];
}
declare type WritableRef<TValue> = Ref<TValue> | WritableComputedRef<TValue>;
interface PrivateFieldComposite<TValue = unknown> {
    fid: number;
    idx: number;
    name: MaybeReactive<string>;
    value: WritableRef<TValue>;
    meta: FieldMeta<TValue>;
    errors: Ref<string[]>;
    errorMessage: ComputedRef<string | undefined>;
    type?: string;
    valueProp?: MaybeReactive<TValue>;
    uncheckedValue?: MaybeReactive<TValue>;
    checked?: ComputedRef<boolean>;
    resetField(state?: FieldState<TValue>): void;
    handleReset(state?: FieldState<TValue>): void;
    validate(): Promise<ValidationResult>;
    handleChange(e: Event | unknown): void;
    handleBlur(e?: Event): void;
    handleInput(e?: Event | unknown): void;
    setValidationState(state: ValidationResult): void;
    setTouched(isTouched: boolean): void;
}
declare type FieldComposable<TValue = unknown> = Omit<PrivateFieldComposite<TValue>, 'idx' | 'fid'>;
declare type SubmitEvent = Event & {
    target: HTMLFormElement;
};
declare type GenericValidateFunction = (value: unknown, ctx: FieldContext) => boolean | string | Promise<boolean | string>;
interface FormState<TValues> {
    values: TValues;
    errors: Partial<Record<keyof TValues, string | undefined>>;
    touched: Partial<Record<keyof TValues, boolean>>;
    submitCount: number;
}
declare type FormErrors<TValues extends Record<string, unknown>> = Partial<Record<keyof TValues, string | undefined>>;
declare type FormErrorBag<TValues extends Record<string, unknown>> = Partial<Record<keyof TValues, string[]>>;
interface SetFieldValueOptions {
    force: boolean;
}
interface FormActions<TValues extends Record<string, unknown>> {
    setFieldValue<T extends keyof TValues>(field: T, value: TValues[T], opts?: Partial<SetFieldValueOptions>): void;
    setFieldError: (field: keyof TValues, message: string | undefined) => void;
    setErrors: (fields: FormErrors<TValues>) => void;
    setValues<T extends keyof TValues>(fields: Partial<Record<T, TValues[T]>>): void;
    setFieldTouched: (field: keyof TValues, isTouched: boolean) => void;
    setTouched: (fields: Partial<Record<keyof TValues, boolean>>) => void;
    resetForm: (state?: Partial<FormState<TValues>>) => void;
}
interface FormValidationResult<TValues> {
    errors: Partial<Record<keyof TValues, string>>;
    valid: boolean;
}
interface SubmissionContext<TValues extends Record<string, unknown> = Record<string, unknown>> extends FormActions<TValues> {
    evt: SubmitEvent;
}
declare type SubmissionHandler<TValues extends Record<string, unknown> = Record<string, unknown>> = (values: TValues, ctx: SubmissionContext<TValues>) => unknown;
interface FormContext<TValues extends Record<string, any> = Record<string, any>> extends FormActions<TValues> {
    register(field: PrivateFieldComposite): void;
    unregister(field: PrivateFieldComposite): void;
    values: TValues;
    fieldsById: ComputedRef<Record<keyof TValues, PrivateFieldComposite | PrivateFieldComposite[]>>;
    submitCount: Ref<number>;
    schema?: Record<keyof TValues, GenericValidateFunction | string | Record<string, any>> | SchemaOf<TValues>;
    validateSchema?: (shouldMutate?: boolean) => Promise<Record<keyof TValues, ValidationResult>>;
    validate(): Promise<FormValidationResult<TValues>>;
    validateField(field: keyof TValues): Promise<ValidationResult>;
    errorBag: Ref<FormErrorBag<TValues>>;
    setFieldErrorBag(field: string, messages: string[]): void;
    stageInitialValue(path: string, value: unknown): void;
    meta: ComputedRef<{
        dirty: boolean;
        touched: boolean;
        valid: boolean;
        pending: boolean;
        initialValues: TValues;
    }>;
    isSubmitting: Ref<boolean>;
    handleSubmit(cb: SubmissionHandler<TValues>): (e?: SubmitEvent) => Promise<void>;
}
interface PublicFormContext<TValues extends Record<string, any> = Record<string, any>> extends Omit<FormContext<TValues>, 'register' | 'unregister' | 'fieldsById' | 'schema' | 'validateSchema' | 'errorBag' | 'setFieldErrorBag' | 'stageInitialValue'> {
    errors: ComputedRef<FormErrors<TValues>>;
    handleReset: () => void;
    submitForm: (e?: unknown) => Promise<void>;
}

interface ValidationOptions {
    name?: string;
    values?: Record<string, unknown>;
    bails?: boolean;
    skipIfEmpty?: boolean;
    isInitial?: boolean;
}
/**
 * Validates a value against the rules.
 */
declare function validate(value: unknown, rules: string | Record<string, unknown | unknown[]> | GenericValidateFunction | YupValidator, options?: ValidationOptions): Promise<ValidationResult>;

/**
 * Adds a custom validator to the list of validation rules.
 */
declare function defineRule<TValue = unknown, TParams = any[] | Record<string, any>>(id: string, validator: ValidationRuleFunction<TValue, TParams> | SimpleValidationRuleFunction<TValue, TParams>): void;

interface VeeValidateConfig {
    bails: boolean;
    generateMessage: ValidationMessageGenerator;
    validateOnInput: boolean;
    validateOnChange: boolean;
    validateOnBlur: boolean;
    validateOnModelUpdate: boolean;
}
declare const configure: (newConf: Partial<VeeValidateConfig>) => void;

declare const Field: vue.DefineComponent<{
    as: {
        type: (ObjectConstructor | StringConstructor)[];
        default: any;
    };
    name: {
        type: StringConstructor;
        required: true;
    };
    rules: {
        type: (ObjectConstructor | FunctionConstructor | StringConstructor)[];
        default: any;
    };
    validateOnMount: {
        type: BooleanConstructor;
        default: boolean;
    };
    validateOnBlur: {
        type: BooleanConstructor;
        default: any;
    };
    validateOnChange: {
        type: BooleanConstructor;
        default: any;
    };
    validateOnInput: {
        type: BooleanConstructor;
        default: any;
    };
    validateOnModelUpdate: {
        type: BooleanConstructor;
        default: any;
    };
    bails: {
        type: BooleanConstructor;
        default: () => boolean;
    };
    label: {
        type: StringConstructor;
        default: any;
    };
    uncheckedValue: {
        type: any;
        default: any;
    };
    modelValue: {
        type: any;
    };
}, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}> | vue.Slot | vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}>[], unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, "update:modelValue"[], "update:modelValue", vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, Readonly<{
    label: string;
    name: string;
    uncheckedValue: any;
    bails: boolean;
    validateOnInput: boolean;
    validateOnChange: boolean;
    validateOnBlur: boolean;
    validateOnModelUpdate: boolean;
    validateOnMount: boolean;
    as: any;
    rules: any;
    modelValue: any;
} & {}>, {
    label: string;
    uncheckedValue: any;
    bails: boolean;
    validateOnInput: boolean;
    validateOnChange: boolean;
    validateOnBlur: boolean;
    validateOnModelUpdate: boolean;
    validateOnMount: boolean;
    as: any;
    rules: any;
    modelValue: any;
}>;

declare const Form: vue.DefineComponent<{
    as: {
        type: StringConstructor;
        default: string;
    };
    validationSchema: {
        type: ObjectConstructor;
        default: any;
    };
    initialValues: {
        type: ObjectConstructor;
        default: any;
    };
    initialErrors: {
        type: ObjectConstructor;
        default: any;
    };
    initialTouched: {
        type: ObjectConstructor;
        default: any;
    };
    validateOnMount: {
        type: BooleanConstructor;
        default: boolean;
    };
    onSubmit: {
        type: PropType<SubmissionHandler<Record<string, unknown>>>;
        default: any;
    };
}, (this: any) => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}> | vue.Slot | vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}>[], unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, Record<string, any>, string, vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, Readonly<{
    onSubmit: SubmissionHandler<Record<string, unknown>>;
    validateOnMount: boolean;
    as: string;
    initialValues: Record<string, any>;
    validationSchema: Record<string, any>;
    initialErrors: Record<string, any>;
    initialTouched: Record<string, any>;
} & {}>, {
    onSubmit: SubmissionHandler<Record<string, unknown>>;
    validateOnMount: boolean;
    as: string;
    initialValues: Record<string, any>;
    validationSchema: Record<string, any>;
    initialErrors: Record<string, any>;
    initialTouched: Record<string, any>;
}>;

declare const ErrorMessage: vue.DefineComponent<{
    as: {
        type: StringConstructor;
        default: any;
    };
    name: {
        type: StringConstructor;
        required: true;
    };
}, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}> | vue.Slot | vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}>[], unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, Record<string, any>, string, vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, Readonly<{
    name: string;
    as: string;
} & {}>, {
    as: string;
}>;

interface FieldOptions<TValue = unknown> {
    initialValue?: MaybeReactive<TValue>;
    validateOnValueUpdate: boolean;
    validateOnMount?: boolean;
    bails?: boolean;
    type?: string;
    valueProp?: MaybeReactive<TValue>;
    uncheckedValue?: MaybeReactive<TValue>;
    label?: MaybeReactive<string>;
}
declare type RuleExpression<TValue> = string | Record<string, unknown> | GenericValidateFunction | YupValidator | BaseSchema<TValue> | undefined;
/**
 * Creates a field composite.
 */
declare function useField<TValue = unknown>(name: MaybeReactive<string>, rules?: MaybeReactive<RuleExpression<TValue>>, opts?: Partial<FieldOptions<TValue>>): FieldComposable<TValue>;

interface FormOptions<TValues extends Record<string, any>> {
    validationSchema?: Record<keyof TValues, GenericValidateFunction | string | Record<string, any>> | SchemaOf<TValues>;
    initialValues?: MaybeReactive<TValues>;
    initialErrors?: Record<keyof TValues, string | undefined>;
    initialTouched?: Record<keyof TValues, boolean>;
    validateOnMount?: boolean;
}
declare function useForm<TValues extends Record<string, any> = Record<string, any>>(opts?: FormOptions<TValues>): PublicFormContext<TValues>;

declare function useResetForm<TValues extends Record<string, unknown> = Record<string, unknown>>(): (state?: Partial<FormState<TValues>>) => void;

/**
 * If a field is dirty or not
 */
declare function useIsFieldDirty(path?: MaybeReactive<string>): vue.ComputedRef<boolean>;

/**
 * If a field is touched or not
 */
declare function useIsFieldTouched(path?: MaybeReactive<string>): vue.ComputedRef<boolean>;

/**
 * If a field is validated and is valid
 */
declare function useIsFieldValid(path?: MaybeReactive<string>): vue.ComputedRef<boolean>;

/**
 * If the form is submitting or not
 */
declare function useIsSubmitting(): vue.ComputedRef<boolean>;

/**
 * Validates a single field
 */
declare function useValidateField(path?: MaybeReactive<string>): () => Promise<ValidationResult>;

/**
 * If the form is dirty or not
 */
declare function useIsFormDirty(): vue.ComputedRef<boolean>;

/**
 * If the form is touched or not
 */
declare function useIsFormTouched(): vue.ComputedRef<boolean>;

/**
 * If the form has been validated and is valid
 */
declare function useIsFormValid(): vue.ComputedRef<boolean>;

/**
 * Validate multiple fields
 */
declare function useValidateForm<TValues extends Record<string, unknown> = Record<string, unknown>>(): () => Promise<FormValidationResult<TValues>>;

/**
 * The number of form's submission count
 */
declare function useSubmitCount(): vue.ComputedRef<number>;

/**
 * Gives access to a field's current value
 */
declare function useFieldValue<TValue = unknown>(path?: MaybeReactive<string>): vue.ComputedRef<TValue>;

/**
 * Gives access to a form's values
 */
declare function useFormValues<TValues extends Record<string, unknown> = Record<string, unknown>>(): vue.ComputedRef<Partial<TValues>>;

/**
 * Gives access to all form errors
 */
declare function useFormErrors<TValues extends Record<string, unknown> = Record<string, unknown>>(): ComputedRef<{}>;

/**
 * Gives access to a single field error
 */
declare function useFieldError(path?: MaybeReactive<string>): vue.ComputedRef<string>;

declare function useSubmitForm<TValues extends Record<string, unknown> = Record<string, unknown>>(cb: SubmissionHandler<TValues>): (e?: SubmitEvent) => Promise<void>;

export { ErrorMessage, Field, Form, FormActions, FormContext, FormState, FormValidationResult, PublicFormContext, SubmissionContext, SubmissionHandler, ValidationResult, configure, defineRule, useField, useFieldError, useFieldValue, useForm, useFormErrors, useFormValues, useIsFieldDirty, useIsFieldTouched, useIsFieldValid, useIsFormDirty, useIsFormTouched, useIsFormValid, useIsSubmitting, useResetForm, useSubmitCount, useSubmitForm, useValidateField, useValidateForm, validate };
